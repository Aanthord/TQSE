<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Quantum Engine - FTC Fixed</title>
    <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/recharts@2.5.0/umd/Recharts.js"></script>
    <script src="https://unpkg.com/@babel/standalone@7.20.0/babel.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #581c87 50%, #0f172a 100%);
            color: white; min-height: 100vh;
        }
        .container { max-width: 1200px; margin: 0 auto; padding: 1.5rem; }
        .header { text-align: center; margin-bottom: 2rem; }
        .title {
            font-size: 2.5rem; font-weight: bold; margin-bottom: 1rem;
            background: linear-gradient(to right, #60a5fa, #a78bfa, #f472b6);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .subtitle { font-size: 1.125rem; color: #d1d5db; }
        .panel {
            background: rgba(31, 41, 55, 0.5); border-radius: 0.5rem;
            padding: 1rem; margin-bottom: 1.5rem; border: 1px solid #374151;
        }
        .controls {
            display: flex; flex-wrap: wrap; align-items: center;
            justify-content: space-between; gap: 1rem; margin-bottom: 1rem;
        }
        .button-group { display: flex; align-items: center; gap: 0.75rem; }
        .btn {
            display: flex; align-items: center; gap: 0.5rem;
            padding: 0.75rem 1.5rem; border-radius: 0.5rem;
            font-weight: 500; border: none; cursor: pointer;
            font-size: 0.875rem; transition: all 0.2s;
        }
        .btn-primary { background: #059669; color: white; }
        .btn-primary:hover { background: #047857; }
        .btn-danger { background: #dc2626; color: white; }
        .btn-danger:hover { background: #b91c1c; }
        .btn-secondary { background: #4b5563; color: white; }
        .btn-secondary:hover { background: #374151; }
        .iteration-display { font-size: 1.125rem; font-family: monospace; }
        .form-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.75rem; margin-top: 1rem;
        }
        .form-group { display: flex; flex-direction: column; }
        .form-label { font-size: 0.875rem; font-weight: 500; margin-bottom: 0.25rem; }
        .form-input {
            margin-top: 0.25rem; padding: 0.5rem 0.75rem;
            background: #374151; border-radius: 0.25rem;
            border: 1px solid #4b5563; color: white; font-size: 0.875rem;
        }
        .form-input:focus { outline: none; border-color: #60a5fa; }
        .charts-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 1.5rem; margin-bottom: 1.5rem;
        }
        .chart-panel {
            background: rgba(31, 41, 55, 0.5); border-radius: 0.5rem;
            padding: 1.5rem; border: 1px solid #374151;
        }
        .chart-title { font-size: 1.125rem; font-weight: 600; margin-bottom: 1rem; }
        .metrics-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;
        }
        .metric-card { padding: 1rem; border-radius: 0.5rem; border: 1px solid; }
        .metric-card.blue { background: rgba(59, 130, 246, 0.1); border-color: rgba(59, 130, 246, 0.3); }
        .metric-card.red { background: rgba(239, 68, 68, 0.1); border-color: rgba(239, 68, 68, 0.3); }
        .metric-card.green { background: rgba(16, 185, 129, 0.1); border-color: rgba(16, 185, 129, 0.3); }
        .metric-card.purple { background: rgba(139, 92, 246, 0.1); border-color: rgba(139, 92, 246, 0.3); }
        .metric-value { font-size: 2rem; font-weight: bold; }
        .metric-value.blue { color: #60a5fa; }
        .metric-value.red { color: #ef4444; }
        .metric-value.green { color: #10b981; }
        .metric-value.purple { color: #8b5cf6; }
        .metric-label { font-size: 0.875rem; color: #d1d5db; }
        .footer { text-align: center; margin-top: 2rem; color: #9ca3af; font-size: 0.875rem; }
        .error { background: #dc2626; color: white; padding: 1rem; border-radius: 0.5rem; margin: 1rem 0; }
    </style>
</head>
<body>
    <div id="root">
        <div class="container">
            <div class="header">
                <h1 class="title">Loading Quantum Engine...</h1>
                <p class="subtitle">If this message persists, check browser console for errors.</p>
            </div>
        </div>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        // Check if Recharts loaded
        if (typeof Recharts === 'undefined') {
            document.getElementById('root').innerHTML = `
                <div class="container">
                    <div class="error">
                        <h2>Error: Recharts failed to load</h2>
                        <p>Please check your internet connection and refresh the page.</p>
                    </div>
                </div>
            `;
            throw new Error('Recharts not loaded');
        }

        const { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } = Recharts;

        // RSF generator
        function generateRSFStructures(depth, complexity, constraints) {
            if (depth <= 0 || depth > 5) return [{ generator: 0, shape: 'base', weight: 1.0, depth: 0 }];
            complexity = Math.max(2, Math.min(4, complexity));
            constraints = Math.max(2, Math.min(4, constraints));
            
            const structures = [];
            const maxStructures = Math.min(50, Math.pow(complexity, depth));
            
            if (depth === 1) {
                for (let g = 0; g < complexity && structures.length < maxStructures; g++) {
                    structures.push({ generator: g, shape: 'primitive', weight: 1 + g * 0.1, depth: 1 });
                }
                return structures;
            }
            
            const prev = generateRSFStructures(depth - 1, complexity, constraints);
            for (const p of prev) {
                if (structures.length >= maxStructures) break;
                for (let c = 0; c < constraints && structures.length < maxStructures; c++) {
                    structures.push({ 
                        generator: p.generator, 
                        shape: `composite_${depth}_${c}`, 
                        weight: p.weight * 1.1, 
                        depth 
                    });
                    if (depth <= 3) {
                        structures.push({ 
                            generator: Array.isArray(p.generator) ? [...p.generator, c] : [p.generator, c], 
                            shape: `hybrid_${depth}`, 
                            weight: p.weight * 1.05, 
                            depth 
                        });
                    }
                }
            }
            return structures.slice(0, maxStructures);
        }

        // Hash function
        function hashStructure(s) {
            const gens = Array.isArray(s.generator) ? s.generator : [s.generator || 0];
            let h = 2166136261;
            for (const g of gens) {
                h ^= (g | 0);
                h = Math.imul(h, 16777619);
            }
            h ^= ((s.depth | 0) * 17);
            const wInt = Math.floor((s.weight || 1) * 1024);
            h ^= (wInt & 0xffffffff);
            h = Math.imul(h, 2246822519);
            h ^= h >>> 15;
            return Math.abs(h);
        }

        // Saturation function
        function delayedSaturation(x, gamma = 0.9) {
            const clamped = Math.min(1, Math.max(0, x));
            if (clamped === 0 || clamped === 1) return clamped;
            const a = Math.pow(clamped, gamma);
            const b = Math.pow(1 - clamped, gamma);
            return a / (a + b);
        }

        // Quantum functions
        function createGroverState(N, markedIndex) {
            const a = 1 / Math.sqrt(N);
            const amplitudes = Array.from({ length: N }, () => ({ real: a, imag: 0 }));
            return { amplitudes, markedIndex, iteration: 0, fidelity: 1 };
        }

        function normalize(amplitudes) {
            const n = Math.sqrt(amplitudes.reduce((s, z) => s + z.real * z.real + z.imag * z.imag, 0));
            return n < 1e-15 ? amplitudes : amplitudes.map(z => ({ real: z.real / n, imag: z.imag / n }));
        }

        function applyOracle(amps, idx) {
            return amps.map((z, i) => i === idx ? { real: -z.real, imag: -z.imag } : z);
        }

        function applyDiffusion(amps) {
            const N = amps.length;
            const ar = amps.reduce((s, z) => s + z.real, 0) / N;
            const ai = amps.reduce((s, z) => s + z.imag, 0) / N;
            return amps.map(z => ({ real: 2 * ar - z.real, imag: 2 * ai - z.imag }));
        }

        function groverIteration(state) {
            const optimal = Math.floor((Math.PI / 4) * Math.sqrt(state.amplitudes.length));
            if (state.iteration >= optimal) {
                const d = state.amplitudes.map(z => ({ real: z.real * 0.95, imag: z.imag * 0.95 }));
                return { ...state, amplitudes: normalize(d), iteration: state.iteration + 1 };
            }
            const a1 = applyOracle(state.amplitudes, state.markedIndex);
            const a2 = applyDiffusion(a1);
            return { ...state, amplitudes: normalize(a2), iteration: state.iteration + 1 };
        }

        function decohere(state, rate) {
            if (rate <= 0) return state;
            const amps = state.amplitudes.map((z, i) => {
                const m = Math.hypot(z.real, z.imag);
                const ph = Math.atan2(z.imag, z.real);
                const m2 = m * (1 - rate * 0.4);
                const ph2 = ph + rate * (i * 0.1);
                return { real: m2 * Math.cos(ph2), imag: m2 * Math.sin(ph2) };
            });
            return { 
                ...state, 
                amplitudes: normalize(amps), 
                fidelity: Math.max(state.fidelity * (1 - rate * 0.5), 0.1) 
            };
        }

        function entropy(amplitudes) {
            let H = 0;
            for (const z of amplitudes) {
                const p = z.real * z.real + z.imag * z.imag;
                if (p > 1e-15) H -= p * Math.log2(p);
            }
            return Math.max(0, H);
        }

        // Main component
        function CompleteQuantumEngine() {
            const [params, setParams] = useState({
                N: 16,
                markedIndex: 5,
                maxIterations: 15,
                decoherenceRate: 0.02,
                rsfDepth: 4,
                generatorComplexity: 2,
                shapeConstraints: 3,
                repairThreshold: 0.8,
            });

            const [isRunning, setIsRunning] = useState(false);
            const [t, setT] = useState(0);
            const [results, setResults] = useState([]);

            // FTC structural estimator
            const structuralD = (depth) => {
                try {
                    const structs = generateRSFStructures(depth, params.generatorComplexity, params.shapeConstraints);
                    const G = Math.max(1, structs.length);
                    let F = 0;
                    for (const s of structs) {
                        if ((hashStructure(s) % params.N) === params.markedIndex) F++;
                    }
                    return F / G;
                } catch (e) {
                    console.error('structuralD error:', e);
                    return 0.1;
                }
            };

            const ftcAt = (iter, groverProb) => {
                try {
                    const i = Math.max(1, Math.min(params.rsfDepth, iter));
                    const Ds = structuralD(i);
                    const coupling = delayedSaturation(Ds + 0.5 * groverProb, 0.9);
                    const w = 0.25;
                    return (1 - w) * Ds + w * coupling;
                } catch (e) {
                    console.error('ftcAt error:', e);
                    return 0.1;
                }
            };

            const run = () => {
                try {
                    let S = createGroverState(params.N, params.markedIndex);
                    const rows = [];
                    let emaFTC = null;
                    const alpha = 0.3;

                    for (let k = 1; k <= params.maxIterations; k++) {
                        S = groverIteration(S);
                        S = decohere(S, params.decoherenceRate);
                        const z = S.amplitudes[params.markedIndex];
                        const p = z.real * z.real + z.imag * z.imag;
                        const H = entropy(S.amplitudes);
                        let dFTC = ftcAt(k, p);
                        emaFTC = emaFTC == null ? dFTC : (alpha * dFTC + (1 - alpha) * emaFTC);
                        
                        rows.push({
                            iteration: k,
                            groverProb: p,
                            ftcTruthDensity: emaFTC,
                            fidelity: S.fidelity,
                            vonNeumannEntropy: H,
                            merkleValid: S.fidelity >= params.repairThreshold ? 1 : 0,
                            needsRepair: S.fidelity < params.repairThreshold ? 1 : 0,
                        });
                    }
                    setResults(rows);
                } catch (e) {
                    console.error('Simulation error:', e);
                    alert('Simulation failed: ' + e.message);
                }
            };

            useEffect(() => {
                if (isRunning && t < params.maxIterations) {
                    const timer = setTimeout(() => setT(x => x + 1), 350);
                    return () => clearTimeout(timer);
                } else if (t >= params.maxIterations) {
                    setIsRunning(false);
                }
            }, [isRunning, t, params.maxIterations]);

            const animatedResults = useMemo(() => {
                if (!isRunning && results.length) return results;
                
                try {
                    let S = createGroverState(params.N, params.markedIndex);
                    const out = [];
                    let emaFTC = null;
                    const alpha = 0.3;
                    
                    for (let k = 1; k <= t; k++) {
                        S = groverIteration(S);
                        S = decohere(S, params.decoherenceRate);
                        const z = S.amplitudes[params.markedIndex];
                        const p = z.real * z.real + z.imag * z.imag;
                        const H = entropy(S.amplitudes);
                        let dFTC = ftcAt(k, p);
                        emaFTC = emaFTC == null ? dFTC : (alpha * dFTC + (1 - alpha) * emaFTC);
                        
                        out.push({
                            iteration: k,
                            groverProb: p,
                            ftcTruthDensity: emaFTC,
                            fidelity: S.fidelity,
                            vonNeumannEntropy: H,
                            merkleValid: S.fidelity >= params.repairThreshold ? 1 : 0,
                            needsRepair: S.fidelity < params.repairThreshold ? 1 : 0
                        });
                    }
                    return out;
                } catch (e) {
                    console.error('Animation error:', e);
                    return [];
                }
            }, [t, isRunning, results, params]);

            const metrics = useMemo(() => {
                if (animatedResults.length === 0) return {};
                const maxGrover = Math.max(...animatedResults.map(r => r.groverProb));
                const maxFTC = Math.max(...animatedResults.map(r => r.ftcTruthDensity));
                const avgF = animatedResults.reduce((s, r) => s + r.fidelity, 0) / animatedResults.length;
                return {
                    maxGrover: maxGrover.toFixed(4),
                    maxFTC: maxFTC.toFixed(4),
                    avgFidelity: avgF.toFixed(4),
                    totalRepairs: animatedResults.filter(r => r.needsRepair === 1).length
                };
            }, [animatedResults]);

            const reset = () => {
                setIsRunning(false);
                setT(0);
                setResults([]);
            };

            const toggle = () => {
                if (!isRunning && t === 0) run();
                setIsRunning(v => !v);
            };

            return React.createElement('div', { className: 'container' }, [
                React.createElement('div', { className: 'header', key: 'header' }, [
                    React.createElement('h1', { className: 'title', key: 'title' }, 'Complete Quantum Engine â€” FTC Fixed'),
                    React.createElement('p', { className: 'subtitle', key: 'subtitle' }, 'FTC computed as F_i/G_i with depth progression and gentle coupling.')
                ]),

                React.createElement('div', { className: 'panel', key: 'controls' }, [
                    React.createElement('div', { className: 'controls', key: 'controls-inner' }, [
                        React.createElement('div', { className: 'button-group', key: 'buttons' }, [
                            React.createElement('button', {
                                key: 'toggle',
                                onClick: toggle,
                                className: `btn ${isRunning ? 'btn-danger' : 'btn-primary'}`
                            }, isRunning ? 'Pause' : (t === 0 ? 'Start Engine' : 'Resume')),
                            React.createElement('button', {
                                key: 'reset',
                                onClick: reset,
                                className: 'btn btn-secondary'
                            }, 'Reset')
                        ]),
                        React.createElement('div', { 
                            className: 'iteration-display', 
                            key: 'iteration' 
                        }, `Iteration: ${t} / ${params.maxIterations}`)
                    ])
                ]),

                React.createElement('div', { className: 'charts-grid', key: 'charts' }, [
                    React.createElement('div', { className: 'chart-panel', key: 'chart1' }, [
                        React.createElement('h3', { className: 'chart-title', key: 'title1' }, 'FTC (F_i/G_i) vs Grover'),
                        React.createElement(ResponsiveContainer, { width: '100%', height: 350, key: 'container1' },
                            React.createElement(LineChart, { data: animatedResults }, [
                                React.createElement(CartesianGrid, { strokeDasharray: '3 3', stroke: '#374151', key: 'grid1' }),
                                React.createElement(XAxis, { dataKey: 'iteration', stroke: '#9CA3AF', key: 'x1' }),
                                React.createElement(YAxis, { stroke: '#9CA3AF', key: 'y1' }),
                                React.createElement(Tooltip, {
                                    key: 'tooltip1',
                                    contentStyle: { backgroundColor: '#1F2937', border: '1px solid #374151' },
                                    labelStyle: { color: '#E5E7EB' }
                                }),
                                React.createElement(Legend, { key: 'legend1' }),
                                React.createElement(Line, {
                                    key: 'grover1',
                                    type: 'monotone',
                                    dataKey: 'groverProb',
                                    stroke: '#3B82F6',
                                    strokeWidth: 3,
                                    name: 'Grover Probability',
                                    dot: { r: 2 }
                                }),
                                React.createElement(Line, {
                                    key: 'ftc1',
                                    type: 'monotone',
                                    dataKey: 'ftcTruthDensity',
                                    stroke: '#EF4444',
                                    strokeWidth: 3,
                                    name: 'FTC Truth-Density (EMA)',
                                    dot: { r: 2 }
                                }),
                                React.createElement(Line, {
                                    key: 'fidelity1',
                                    type: 'monotone',
                                    dataKey: 'fidelity',
                                    stroke: '#10B981',
                                    strokeWidth: 2,
                                    strokeDasharray: '3 3',
                                    name: 'Quantum Fidelity'
                                })
                            ])
                        )
                    ])
                ]),

                React.createElement('div', { className: 'panel', key: 'metrics' }, [
                    React.createElement('h3', { className: 'chart-title', key: 'metrics-title' }, 'Performance Metrics'),
                    React.createElement('div', { className: 'metrics-grid', key: 'metrics-grid' }, [
                        React.createElement('div', { className: 'metric-card blue', key: 'metric1' }, [
                            React.createElement('div', { className: 'metric-value blue', key: 'value1' }, metrics.maxGrover || '0.0625'),
                            React.createElement('div', { className: 'metric-label', key: 'label1' }, 'Max Grover')
                        ]),
                        React.createElement('div', { className: 'metric-card red', key: 'metric2' }, [
                            React.createElement('div', { className: 'metric-value red', key: 'value2' }, metrics.maxFTC || '0.0000'),
                            React.createElement('div', { className: 'metric-label', key: 'label2' }, 'Max FTC')
                        ]),
                        React.createElement('div', { className: 'metric-card green', key: 'metric3' }, [
                            React.createElement('div', { className: 'metric-value green', key: 'value3' }, metrics.avgFidelity || '1.0000'),
                            React.createElement('div', { className: 'metric-label', key: 'label3' }, 'Average Fidelity')
                        ]),
                        React.createElement('div', { className: 'metric-card purple', key: 'metric4' }, [
                            React.createElement('div', { className: 'metric-value purple', key: 'value4' }, metrics.totalRepairs || '0'),
                            React.createElement('div', { className: 'metric-label', key: 'label4' }, 'Repairs')
                        ])
                    ])
                ])
            ]);
        }

        // Render with error handling
        try {
            ReactDOM.render(React.createElement(CompleteQuantumEngine), document.getElementById('root'));
        } catch (error) {
            console.error('Render error:', error);
            document.getElementById('root').innerHTML = `
                <div class="container">
                    <div class="error">
                        <h2>Rendering Error</h2>
                        <p>Error: ${error.message}</p>
                        <p>Please check the browser console for more details.</p>
                    </div>
                </div>
            `;
        }
    </script>
</body>
</html>
